import { invertMatrix, linearTransform, multiplyMatrices, roundMatrix } from '../src/ColorMatrix';

describe('Multiply matrices', () => {
  test(`linearTransform(Matrix3x3, Matrix1x3)`, () => {
    const a = [
      [3.2404542, -1.5371385, -0.4985314],
      [-0.969266, 1.8760108, 0.041556],
      [0.0556434, -0.2040259, 1.0572252],
    ];
    const b = [0.9869929, -0.1470543, 0.1599627];

    const expected = [3.3446016855169494, -1.22588670523664, 0.25403912413827];
    const result = linearTransform(a, b);
    expect(result).toEqual(expected);
  });

  test(`multiplyMatrices(Matrix3x3, Matrix3x3)`, () => {
    const a = [
      [3.2404542, -1.5371385, -0.4985314],
      [-0.969266, 1.8760108, 0.041556],
      [0.0556434, -0.2040259, 1.0572252],
    ];
    const b = [
      [0.9869929, -0.1470543, 0.1599627],
      [0.4323053, 0.5183603, 0.0492912],
      [-0.0085287, 0.0400428, 0.9684867],
    ];
    const expected = [
      [2.5380439925423093, -1.29327689120853, -0.040236628605239966],
      [-0.14600366717135996, 1.1166482728318399, -0.022329149528039993],
      [-0.04229859373865001, -0.07160727072983, 1.02275273216394],
    ];

    const result = multiplyMatrices(a, b);
    expect(result).toEqual(expected);
  });
});

describe('Invert matrix', () => {
  const matrices = [
    // sample data: http://www.brucelindbloom.com/index.html?Eqn_ChromAdapt.html
    {
      name: 'XYZ scaling',
      m: [
        [1.0, 0.0, 0.0],
        [0.0, 1.0, 0.0],
        [0.0, 0.0, 1.0],
      ],
      mi: [
        [1.0, 0.0, 0.0],
        [0.0, 1.0, 0.0],
        [0.0, 0.0, 1.0],
      ],
      round: 7,
    },
    {
      name: 'von Kries',
      m: [
        [0.40024, 0.7076, -0.08081],
        [-0.2263, 1.16532, 0.0457],
        [0.0, 0.0, 0.91822],
      ],
      mi: [
        [1.8599364, -1.1293816, 0.2198974],
        [0.3611914, 0.6388125, -0.0000064],
        [0.0, 0.0, 1.0890636],
      ],
      round: 7,
    },
    {
      name: 'Bradford',
      m: [
        [0.8951, 0.2664, -0.1614],
        [-0.7502, 1.7135, 0.0367],
        [0.0389, -0.0685, 1.0296],
      ],
      mi: [
        [0.9869929, -0.1470543, 0.1599627],
        [0.4323053, 0.5183603, 0.0492912],
        [-0.0085287, 0.0400428, 0.9684867],
      ],
      round: 7,
    },
    {
      name: 'CAT02',
      m: [
        [0.7328, 0.4296, -0.1624],
        [-0.7036, 1.6975, 0.0061],
        [0.003, 0.0136, 0.9834],
      ],
      mi: [
        [1.0961238, -0.278869, 0.1827452],
        [0.454369, 0.4735332, 0.0720978],
        [-0.0096276, -0.005698, 1.0153256],
      ],
      round: 7,
    },
    {
      name: 'CAT16',
      m: [
        [0.401288, 0.650173, -0.051461],
        [-0.250268, 1.204414, 0.045854],
        [-0.002079, 0.048952, 0.953127],
      ],
      // test the extra precision
      mi: [
        [1.8620678550872327, -1.0112546305316843, 0.14918677544445172],
        [0.3875265432361371, 0.6214474419314753, -0.00897398516761252],
        [-0.015841498849333856, -0.03412293802851556, 1.0499644368778493],
      ],
      round: -1,
    },

    // sample data: https://drafts.csswg.org/css-color/#color-conversion-code lin_sRGB_to_XYZ()
    {
      name: 'rgbToXyz',
      m: [
        [0.41239079926595934, 0.357584339383878, 0.1804807884018343],
        [0.21263900587151027, 0.715168678767756, 0.07219231536073371],
        [0.01933081871559182, 0.11919477979462598, 0.9505321522496607],
      ],
      mi: [
        [3.240969941904523, -1.5373831775700944, -0.49861076029300355],
        [-0.96924363628088, 1.875967501507721, 0.04155505740717559],
        [0.055630079696993656, -0.20397695888897657, 1.0569715142428788],
      ],
      round: -1,
    },

    {
      name: 'rgbToXyz (4 paces)',
      m: [
        [0.4124, 0.3576, 0.1805],
        [0.2126, 0.7152, 0.0722],
        [0.0193, 0.1192, 0.9505],
      ],
      mi: [
        [3.2406, -1.5372, -0.4986],
        [-0.9689, 1.8758, 0.0415],
        [0.0557, -0.204, 1.057],
      ],
      round: 4,
    },
  ];

  matrices.map((item) => {
    test(item.name, () => {
      const expected = item.mi;
      const result = item.round >= 0 ? roundMatrix(invertMatrix(item.m), item.round) : invertMatrix(item.m);
      expect(result).toEqual(expected);
    });
  });
});